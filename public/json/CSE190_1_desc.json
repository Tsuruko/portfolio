{
	"isCSE190_1": true,
	"Brighten" : {
		"Header": "Brighten",
		"CLA": "./image -brightness [factor] < in.bmp > out.bmp",
		"Summary": "Brightness is controlled by scaling the pixels by the inputed factor.  The factor must be non-negative.  1.0 preserves the image, 0.0 makes it black, and other factors scale up the pixel values."
	},
	"ChangeContrast" : {
		"Header": "Change Contrast",
		"CLA": "./image -contrast [factor] < in.bmp > out.bmp",
		"Summary": "Contrast is controlled by interpolating the pixels between a gray image of the average image luminance and the original image.  A factor of 0.0 outputs the calculated constant gray image, 1.0 gives the original image, and negative values inverts the image.  Values between 0.0 and 1.0 have less contrast, and values greater than 1.0 has higher contrast."
	},
	"ChangeSaturation" : {
		"Header": "Change Saturation",
		"CLA": "./image -saturation [factor] < in.bmp > out.bmp",
		"Summary": "Saturation is controlled by interpolating the pixels between a gray-scale version of the original image and the original image.  The grayscale image is constructed form the pixel luminance.  Negative values inverts the image hue but keeps the luminance.  A factor of 0.0 outputs the calculated greyscale image, 1.0 preserves the original image, and negative values invert the colors.  Values between 0.0 and 1.0 make the image more gray, and values greater than 1.0 are extrapolated to increase the saturation."
	},
	"ChangeGamma" : {
		"Header": "Change Gamma",
		"CLA": "./image -gamma [factor] < in.bmp > out.bmp",
		"Summary": "Gamma correction adjusts the color of each pixel of the image by the factor.  The factor must be a postitive number.  A factor of 1.0 preserves the original image, values greater than 1 brighten the image, and values less than 1 darken it."
	},
	"Crop" : {
		"Header": "Crop",
		"CLA": "./image -crop [x] [y] [w] [h] < in.bmp > out.bmp",
		"Summary": "Cropping is done by selecting a rectangular section of the image at the given starting point up to the size specified.  x and y are the point to begin cropping from, and w and h are the size of the output cropped image.  The x value must be in the range 0 to width-1(left to right) and y must be in the range 0 to height -1 (top to bottom). All parameters must be postive."
	},

	"Quantize" : {
		"Header": "Quantize",
		"CLA": "./image -quantize [bits] < in.bmp > out.bmp",
		"Summary": "For each color channel in the image I first convert the value to a floating point number <i>p</i> between 0 and 1, then use <i>q = floor(p * b)</i>, where <i>b = 2^bits</i>.  I then convert back to the 0-255 range using <i>color = floor(255*q/(b-1))</i>."
	},
	"RandomDither" : {
		"Header": "Random Dither",
		"CLA": "./image -randomDither [bits] < in.bmp > out.bmp",
		"Summary": "I then added an option to add random noise to the quantizing function.  THe noise ranges from -0.5 to 0.5, and is added using <i>q = floor(p*b + noise)</i>."
	},
	"FloydSteinbergDither" : {
		"Header": "Floyd Steinberg Dither",
		"CLA": "./image -FloydSteinbergDither [bits] < in.bmp > out.bmp",
		"Summary": "In this algorithm the error made during quantizing is diffused to other pixels later on using the given weights:</br>Right = 7/16, bottomleft = 3/16, bottom = 5/16, bottomright = 1/16."
	},

	"Blur" : {
		"Header": "Blur",
		"CLA": "./image -blur [width] < in.bmp > out.bmp",
		"Summary": "The blur kernel width parameter must be an odd integer.  A gaussian filter with the given width is used for discrete convolution with the image.  I set <i>sigma = floor(n/2.0)/2.0</i> as given in the assignment."
	},
	"Sharpen" : {
		"Header": "Sharpen",
		"CLA": "./image -sharpen < in.bmp > out.bmp",
		"Summary": "I used the filter provided in the assignment writeup."
	},
	"EdgeDetect" : {
		"Header": "Edge Detection",
		"CLA": "./image -edgeDetect [threshold] < in.bmp > out.bmp",
		"Summary": "Edge detection using sobel filters"
	},

	"Scale" : {
		"Header": "Scale",
		"CLA": "./image -sampling [type] -size [w] [h] < in.bmp > out.bmp",
		"Summary": "Nearest Neighbor:"
	},
	"Shift" : {
		"Header": "Shift",
		"CLA": "./image -shift [sx] [sy] < in.bmp >out.bmp",
		"Summary": "Nearest Neighbor:"
	},

	"funNonLinear" : {
		"Header": "Fun Nonlinear filters",
		"CLA": "./image -fun < in.bmp >out.bmp",
		"Summary": "I decided to implement a swirl effect. I use the mitchell filter for anti-aliasing.  I searched for math equations for the swirl effect online and found several different ones.  All of these left black pixels where there were no image pixels to sample, but I instead used my sampling method which uses the wrapping method.  The function I chose to use to transform the pixels is <strong>newX = x*cos(angle) - y*sin(angle) +xcenter</strong> and <strong>newY = x*sin(angle) + y*cos(angle) + ycenter</strong> and <strong>r = (x*x + y*y)</strong> where angle is a function of r."
	}
}